---
// Design System
import '../styles/header.css';
---

<!-- Hamburger button - outside header for proper z-index stacking -->
<button class="hamburger" aria-label="Toggle menu">
  <span></span>
  <span></span>
</button>

<header id="site-header" class="site-header">
  <nav class="site-nav">
    <a href="/" class="logo-container">
      <span class="logo">Akrad√©</span>
    </a>
  </nav>
</header>

<!-- Mega Menu -->
<div class="mega-menu">
  <nav class="mega-menu-nav">
    <ul class="mega-menu-links">
      <li><a href="/about" class={Astro.url.pathname === '/about' ? 'active' : ''}>About</a></li>
      <li><a href="/services" class={Astro.url.pathname === '/services' ? 'active' : ''}>Services</a></li>
      <li><a href="/contact" class={Astro.url.pathname === '/contact' ? 'active' : ''}>Contact</a></li>
    </ul>
  </nav>
</div>

<script>
  // @ts-nocheck
  // Menu functionality - works with both initial load and View Transitions
  (function() {
    let cleanupFunctions = [];

    function initMenu() {
      // Cleanup any existing listeners first
      cleanupFunctions.forEach(fn => fn());
      cleanupFunctions = [];

      // Cache DOM queries
      const hamburger = document.querySelector('.hamburger');
      const megaMenu = document.querySelector('.mega-menu');
      const megaMenuLinks = document.querySelectorAll('.mega-menu a');
      const footer = document.querySelector('footer');

      // Only initialize if elements exist
      if (!hamburger || !megaMenu) return;

      // Mega menu handlers - toggle with hamburger
      const toggleMenu = () => {
        const isOpen = megaMenu.classList.contains('open');

        if (isOpen) {
          megaMenu.classList.remove('open');
          hamburger.classList.remove('active');
          document.body.style.overflow = '';
          // Restore footer z-index when menu closes
          if (footer) footer.style.zIndex = '';
        } else {
          megaMenu.classList.add('open');
          hamburger.classList.add('active');
          document.body.style.overflow = 'hidden';
          // Force footer behind menu overlay when menu opens
          if (footer) footer.style.zIndex = '0';
        }
      };

      const closeMenuFn = () => {
        megaMenu.classList.remove('open');
        hamburger.classList.remove('active');
        document.body.style.overflow = '';
        // Restore footer z-index when menu closes
        if (footer) footer.style.zIndex = '';
      };

      // ESC key to close menu
      const escHandler = (e) => {
        if (e.key === 'Escape' && megaMenu.classList.contains('open')) closeMenuFn();
      };

      // Add event listeners
      hamburger.addEventListener('click', toggleMenu);
      megaMenuLinks.forEach(link => link.addEventListener('click', closeMenuFn));
      document.addEventListener('keydown', escHandler);

      // Store cleanup functions
      cleanupFunctions.push(() => {
        hamburger.removeEventListener('click', toggleMenu);
        megaMenuLinks.forEach(link => link.removeEventListener('click', closeMenuFn));
        document.removeEventListener('keydown', escHandler);
      });
    }

    // Initialize immediately on first load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMenu);
    } else {
      initMenu();
    }

    // Re-initialize after View Transitions navigation
    document.addEventListener('astro:page-load', initMenu);

    // Cleanup before navigation
    document.addEventListener('astro:before-preparation', () => {
      cleanupFunctions.forEach(fn => fn());
      cleanupFunctions = [];
    });
  })();
</script>
